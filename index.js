const express = require("express");
const app = express();
const db = require("./db");
const s3 = require("./s3");
const { s3Url } = require("./config.json");

// Multer is a node.js middleware for handling multipart/form-data, which is primarily used for uploading files. It is written on top of busboy for maximum efficiency:
const multer = require("multer");
const uidSafe = require("uid-safe");
const path = require("path");

// The object returned from the call to multer.diskStorage specifies functions that multer should use for determining the path and filename to use when saving files. The destination function tells multer to put files in the uploads directory and the filename function tells multer to use as the file name the unique id generated by the call to uidSafe with the extension of the original file name appended to it.

const diskStorage = multer.diskStorage({
    destination: function (req, file, callback) {
        callback(null, __dirname + "/uploads");
    },
    filename: function (req, file, callback) {
        uidSafe(24).then(function (uid) {
            callback(null, uid + path.extname(file.originalname));
        });
    },
});

// The diskStorage object is then passed to multer, along with an object specifying a file size limit (2MB). It is a good idea to place such limits to prevent DOS attacks. The full list of limits you can apply is available

const uploader = multer({
    storage: diskStorage,
    limits: {
        fileSize: 2097152,
    },
});

// /////////////////////////////////// MIDLEWARE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\
app.use(
    express.urlencoded({
        extended: false,
    })
);

app.get("/images", (req, res) => {
    db.getImages()
        .then(({ rows }) => {
            console.log("rows: ", rows);
            res.json(rows);
        })
        .catch((err) => {
            console.log(`db.getImages - read form the DB failed: `, err);
        });
});

// The object returned from this call to multer has middleware functions attached to it that can be used to handle uploads on specific routes. You do not want to pass any of these functions to app.use because you only want to allow uploads on specific routes:
// The call to single indicates that we are only expecting one file. The string passed to single is the name of the field in the request:
app.post("/upload", uploader.single("file"), s3.upload, function (req, res) {
    // If nothing went wrong the file is already in the uploads directory
    const { title, username, description } = req.body;
    const url = `${s3Url}${req.file.filename}`;
    // console.log("req.body: ", req.body);
    // console.log("url: ", url);
    if (req.file) {
        db.uploadImages(url, username, title, description)
            .then(() => {
                res.json({ url, username, title, description });
                console.log(
                    "image uploaded: ",
                    res.json({ url, username, title, description })
                );
            })
            .catch((err) => {
                console.log("error while uploading image to DB: ", err);
            });
    } else {
        res.json({
            success: false,
        });
    }
});

app.get("/clicked-image/:id", (req, res) => {
    console.log("req.params: ", req.params);
    const { id } = req.params;
    db.getClickedImageDetails(id)
        .then(({ rows }) => {
            res.json(rows);
        })
        .catch((err) => {
            console.log("error in reading selected image details: ", err);
        });
});

// in general it is good practice to serve files with express.static last!
app.use(express.static("public"));

app.listen(8080, () => console.log("imageboard up and running"));
